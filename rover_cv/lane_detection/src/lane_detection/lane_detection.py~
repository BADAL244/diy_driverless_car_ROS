#!/usr/bin/env python
# -*- coding: utf-8 -*-
# https://github.com/paramaggarwal/CarND-LaneLines-P1/blob/master/P1.ipynb
from __future__ import print_function
import roslib
roslib.load_manifest('formulapi_sitl')
import sys
import traceback
import rospy
import cv2
import numpy as np
import math
import logging
import socket
import threading
import time
import datetime
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from geometry_msgs.msg import Twist

class lane_detection(object):
    def __init__(self):
            
      """ROS Subscriptions """
      self.image_pub = rospy.Publisher("/image_converter/output_video",Image, queue_size=10)
      self.image_sub = rospy.Subscriber("/cam/camera_/image_raw",Image,self.cvt_image)
      self.cmdVelocityPub = rospy.Publisher('/platform_control/cmd_vel', Twist, queue_size=10)

      """ Variables """
      self.bridge = CvBridge()
      self.latestImage = None
      self.outputImage = None
      self.process = False

      self.kernel_size_blur = 50
      self.processedImage = None

      self.targetlane = 0
      self.cmdvel = Twist()
      self.last_time = rospy.Time()
      self.sim_time = rospy.Time()
      self.dt = 0
      self.pos = 0
      self.position_er = 0
      self.position_er_last = 0
      self.cp = 0
      self.vel_er = 0
      self.cd = 0
      self.Kp = 3
      self.Kd = 3.5
      
    def limit(self, input, min, max):
	if input < min:
		input = min
	if input > max:
		input = max
	return input

    def AdjustMotorSpeed(self, pos):

	self.cmdvel.linear.x = 0.2

	self.sim_time = rospy.Time.now()
	self.dt = (self.sim_time - self.last_time).to_sec();

	self.position_er = self.targetlane - pos
	self.cp = self.position_er * self.Kp 
	self.vel_er = (self.position_er - self.position_er_last) * self.dt
	self.cd = self.vel_er * self.Kd

	self.cmdvel.angular.z = self.cp - self.cd
	self.cmdvel.angular.z = self.limit(self.cmdvel.angular.z, -1, 1)
	self.cmdVelocityPub.publish(self.cmdvel)

	self.position_er_last = self.position_er
	self.last_time = self.sim_time

    def cvt_image(self,data):  
      try:
        self.latestImage = self.bridge.imgmsg_to_cv2(data, "bgr8")	
      except CvBridgeError as e:
        print(e)
      if self.process != True:
          self.process = True    

    def process_image(self, image):

      #Gaussian Blur
      blurredImage = cv2.GaussianBlur(image, (11,11), 0) 

      #Canny edge detection
      edgesImage = cv2.Canny(blurredImage, 40, 50) 
   
      #Define region of interest for cropping
      height = image.shape[0]
      width = image.shape[1]
      vertices = np.array( [[
                [3*width/4, 3*height/5],
                [width/4, 3*height/5],
                [40, height],
                [width - 40, height]
            ]], dtype=np.int32 )

      #defining a blank mask to start with
      mask = np.zeros_like(edgesImage)   
      
      #defining a 3 channel or 1 channel color to fill the mask with depending on the input image
      if len(edgesImage.shape) > 2:
          channel_count = edgesImage.shape[2]  # i.e. 3 or 4 depending on your image
          ignore_mask_color = (255,) * channel_count
      else:
          ignore_mask_color = 255
      
      #filling pixels inside the polygon defined by "vertices" with the fill color    
      cv2.fillPoly(mask, vertices, ignore_mask_color)
    
      #returning the image only where mask pixels are nonzero
      maskedImage = cv2.bitwise_and(edgesImage, mask)

      """
      `img` should be the output of a Canny transform.
        
      Returns an image with hough lines drawn.
      """

      rho = 1
      theta = np.pi/180
      threshold = 40
      min_line_len = 30
      max_line_gap = 200

      lines = cv2.HoughLinesP(maskedImage, rho, theta, threshold, np.array([]), minLineLength=min_line_len, maxLineGap=max_line_gap)
      line_img = np.zeros(image.shape, dtype=np.uint8)
      #draw_lines(line_img, lines)

      self.processedImage = maskedImage

    def run(self):

      while True:
	
	# Only run loop if we have an image
	if self.process:

      	    self.process_image(self.latestImage)	# Lane Detection Function

            #self.AdjustMotorSpeed(self.pos)	# Compute Motor Commands From Image Output

	    # Publish Processed Image
	    cvImage = self.processedImage
	    try:
	    	imgmsg = self.bridge.cv2_to_imgmsg(cvImage, "mono8") 
                #imgmsg = self.bridge.cv2_to_imgmsg(cvImage, "bgr8") 
	    	self.image_pub.publish(imgmsg)
	    except CvBridgeError as e:
            	print(e)
	    
            #cv2.imshow("Image window", self.cvImage)
            #cv2.waitKey(3)

def main(args):

  rospy.init_node('lane_detection', anonymous=True)

  ld = lane_detection() 

  ld.run() 


  try:
    rospy.spin()
  except KeyboardInterrupt:
    print("Shutting down")
  cv2.destroyAllWindows()

if __name__ == '__main__':
    main(sys.argv)
